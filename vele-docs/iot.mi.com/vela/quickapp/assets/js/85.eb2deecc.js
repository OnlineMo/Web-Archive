(window.webpackJsonp=window.webpackJsonp||[]).push([[85],{567:function(t,e,v){"use strict";v.r(e);var a=v(18),o=Object(a.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"组件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#组件"}},[t._v("#")]),t._v(" 组件")]),t._v(" "),e("p",[t._v("组件分为预定义组件和自定义组件。")]),t._v(" "),e("p",[t._v("预定义组件是框架预先定义好、由框架实现渲染和逻辑的组件，例如开发页面时开发者必须用到的 text、div，这些组件是由平台 Native 底层渲染出来的。")]),t._v(" "),e("p",[t._v("如果开发一个复杂的页面，开发者把所有的 UI 部分写在一个文件的"),e("code",[t._v("<template>")]),t._v("，那代码的可维护性将会很低，并且模块之间容易产生不必要的耦合关系，为了更好地组织逻辑与代码，可以把页面按照功能拆成多个模块，每个模块负责其中的一个功能部分，最后页面将这些模块引入管理起来，传递业务与配置数据完成代码分离，那么这就是自定义组件的意义。")]),t._v(" "),e("p",[e("RouterLink",{attrs:{to:"/zh/guide/framework/template/component.html"}},[t._v("自定义组件")]),t._v("是一个开发者编写的组件，使用起来和 Native 组件一样，最终按照组件的"),e("code",[t._v("<template>")]),t._v("来渲染；同时开发起来又和页面一样，拥有 ViewModel 实现对数据、事件、方法的管理。")],1),t._v(" "),e("p",[t._v("这么来看，页面也是一种特殊的自定义组件，无需引入即可使用，同时服务于整个页面。")]),t._v(" "),e("p",[t._v("本章节主要详细介绍预定义的 Native 组件的用法，包括其支持的样式、属性、事件。")])])}),[],!1,null,null,null);e.default=o.exports}}]);