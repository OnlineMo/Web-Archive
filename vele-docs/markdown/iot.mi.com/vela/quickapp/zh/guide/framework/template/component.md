::: {#app server-rendered="true"}
::: theme-container
::: navbar
::: sidebar-button
![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGFyaWEtaGlkZGVuPSJ0cnVlIiByb2xlPSJpbWciIHZpZXdib3g9IjAgMCA0NDggNTEyIiBjbGFzcz0iaWNvbiI+PHBhdGggZmlsbD0iY3VycmVudENvbG9yIiBkPSJNNDM2IDEyNEgxMmMtNi42MjcgMC0xMi01LjM3My0xMi0xMlY4MGMwLTYuNjI3IDUuMzczLTEyIDEyLTEyaDQyNGM2LjYyNyAwIDEyIDUuMzczIDEyIDEydjMyYzAgNi42MjctNS4zNzMgMTItMTIgMTJ6bTAgMTYwSDEyYy02LjYyNyAwLTEyLTUuMzczLTEyLTEydi0zMmMwLTYuNjI3IDUuMzczLTEyIDEyLTEyaDQyNGM2LjYyNyAwIDEyIDUuMzczIDEyIDEydjMyYzAgNi42MjctNS4zNzMgMTItMTIgMTJ6bTAgMTYwSDEyYy02LjYyNyAwLTEyLTUuMzczLTEyLTEydi0zMmMwLTYuNjI3IDUuMzczLTEyIDEyLTEyaDQyNGM2LjYyNyAwIDEyIDUuMzczIDEyIDEydjMyYzAgNi42MjctNS4zNzMgMTItMTIgMTJ6Ij48L3BhdGg+PC9zdmc+){.icon}
:::

[![Xiaomi Vela JS 应用开发文档](../../../../logo.png){.logo} [Xiaomi
Vela JS 应用开发文档]{.site-name
.can-hide}](https://iot.mi.com/vela/quickapp/){.home-link
.router-link-active}

::: links
::: search-box
:::

::: nav-item
[教程](../../version/APILevel4.html){.nav-link .router-link-active}
:::

::: nav-item
[组件](../../../components/index.html){.nav-link}
:::

::: nav-item
[JS接口](../../../features/index.html){.nav-link}
:::

::: nav-item
[编程示例](../../../samples/index.html){.nav-link}
:::

::: nav-item
[工具](../../../tools/index.html){.nav-link}
:::
:::
:::

::: sidebar-mask
:::

::: nav-item
[教程](../../version/APILevel4.html){.nav-link .router-link-active}
:::

::: nav-item
[组件](../../../components/index.html){.nav-link}
:::

::: nav-item
[JS接口](../../../features/index.html){.nav-link}
:::

::: nav-item
[编程示例](../../../samples/index.html){.nav-link}
:::

::: nav-item
[工具](../../../tools/index.html){.nav-link}
:::

-   ::: {.section .sidebar-group .depth-0}
    [快速入门](https://iot.mi.com/vela/quickapp/zh/guide/start){.sidebar-heading
    .clickable}
    -   [安装环境](../../start/use-ide.html){.sidebar-link}
    -   [项目结构](../../start/project-overview.html){.sidebar-link}
    -   [编写页面UI](../../start/user-interface.html){.sidebar-link}
    -   [添加交互](../../start/add-interactivity.html){.sidebar-link}
    -   [数据获取](../../start/data-fetch.html){.sidebar-link}
    -   [编译参数](../../start/toolkit-params.html){.sidebar-link}
    :::

-   ::: {.section .sidebar-group .depth-0}
    [基础功能](../index.html){.sidebar-heading .clickable
    .router-link-active .open}
    -   [项目结构](../project-structure.html){.sidebar-link}

    -   [项目配置](../manifest.html){.sidebar-link}

    -   [UX 文件](../ux.html){.sidebar-link}

    -   ::: {.section .sidebar-group .collapsable .is-sub-group .depth-1}
        [模板语法 []{.arrow .down}](index.html){.sidebar-heading
        .clickable .router-link-active .open}
        -   [Props](Props.html){.sidebar-link}
        -   [事件绑定](event.html){.sidebar-link}
        -   [循环指令](for.html){.sidebar-link}
        -   [条件指令](if.html){.sidebar-link}
        -   [计算属性](computed.html){.sidebar-link}
        -   [组件](component.html){.active .sidebar-link
            aria-current="page"}
        :::

    -   ::: {.section .sidebar-group .collapsable .is-sub-group .depth-1}
        [样式语法 []{.arrow
        .right}](../style/index.html){.sidebar-heading .clickable}
        :::

    -   ::: {.section .sidebar-group .collapsable .is-sub-group .depth-1}
        [脚本语法 []{.arrow
        .right}](../script/index.html){.sidebar-heading .clickable}
        :::

    -   [页面切换](../page-switch.html){.sidebar-link}
    :::

-   ::: {.section .sidebar-group .depth-0}
    [进阶功能](../other/index.html){.sidebar-heading .clickable}
    -   [多语言覆盖](../other/i18n.html){.sidebar-link}

    -   [后台运行](../other/background-running.html){.sidebar-link}

    -   [hap 链接](../other/hap-schema.html){.sidebar-link}

    -   [页面启动模式](../other/launch-mode.html){.sidebar-link}

    -   ::: {.section .sidebar-group .is-sub-group .depth-1}
        [多屏适配](../../multi-screens/index.html){.sidebar-heading
        .clickable}
        -   [适配规范](../../multi-screens/specs.html){.sidebar-link}
        -   [代码示例](../../multi-screens/samples.html){.sidebar-link}
        -   [条件编译](../../multi-screens/conditional-compilation.html){.sidebar-link}
        :::
    :::

-   ::: {.section .sidebar-group .depth-0}
    [开发者物料](../../developer-materials/index.html){.sidebar-heading
    .clickable}
    -   [拓展组件](../../developer-materials/extension-components.html){.sidebar-link}
    :::

-   ::: {.section .sidebar-group .depth-0}
    [设计指南](../../design/index.html){.sidebar-heading .clickable}
    -   [多屏设计](../../design/multi-screens.html){.sidebar-link}
    :::

-   ::: {.section .sidebar-group .depth-0}
    [最佳实践](../../best-practice/index.html){.sidebar-heading
    .clickable}
    -   [内存优化](../../best-practice/memory.html){.sidebar-link}
    -   [常用业务优化](../../best-practice/business.html){.sidebar-link}
    -   [启动时延优化](../../best-practice/start.html){.sidebar-link}
    :::

-   ::: {.section .sidebar-group .depth-0}
    [发布](../../publish/index.html){.sidebar-heading .clickable}
    -   [验收标准](../../publish/acceptance-criteria.html){.sidebar-link}
    :::

-   ::: {.section .sidebar-group .depth-0}
    [版本说明](../../version/index.html){.sidebar-heading .clickable}
    -   [APILevel2](https://iot.mi.com/vela/quickapp/zh/guide/version/APILevel2.html){.sidebar-link}
    -   [APILevel3](https://iot.mi.com/vela/quickapp/zh/guide/version/APILevel3.html){.sidebar-link}
    -   [APILevel4](https://iot.mi.com/vela/quickapp/zh/guide/version/APILevel4.html){.sidebar-link}
    :::

-   ::: {.section .sidebar-group .depth-0}
    其他

    -   [常见问题](../../other/faq.html){.sidebar-link}
    -   [注意事项](../../other/tips.html){.sidebar-link}
    :::

::: {.page role="main"}
::: {.theme-default-content .content__default}
# [\#](component.html#组件){.header-anchor} 组件

## [\#](component.html#组件自定义){.header-anchor} 组件自定义

开发页面时开发者必须用到 Native
组件，如：`text`、`div`，这些组件是由各平台 Native
底层渲染出来的；如果开发一个复杂的页面，开发者把所有的 UI
部分写在一个文件的`<template>`，那代码的可维护性将会很低，并且模块之间容易产生不必要的耦合关系。

为了更好的组织逻辑与代码，可以把页面按照功能拆成多个模块，每个模块负责其中的一个功能部分，最后页面将这些模块引入管理起来，传递业务与配置数据完成代码分离，那么这就是自定义组件的意义。

自定义组件是一个开发者编写的组件，使用起来和 Native
一样，最终按照组件的`<template>`来渲染；同时开发起来又和页面一样，拥有
ViewModel 实现对数据、事件、方法的管理。

::: {.custom-block .tip}
提示

由于自定义组件拥有独立的ViewModel，因此存在一定内存开销，在手表手环等轻量级设备上不建议使用。
:::

**示例如下：**

::: {.language-html .extra-class}
``` language-html
<template>
  <div class="tutorial-page">
    <text class="tutorial-title">自定义组件:</text>
    <text>{{ say }}</text>
    <text>{{ obj.name }}</text>
  </div>
</template>

<style lang="less">
  .tutorial-page {
    flex-direction: column;
    padding-top: 20px;

    .tutorial-title {
      font-weight: bold;
    }
  }
</style>

<script>
  // 子组件
  export default {
    data: {
      say: 'hello',
      obj: {
        name: 'quickApp'
      }
    },
    onInit() {
      console.log('我是子组件')
    }
  }
</script>
```
:::

自定义组件中数据模型只能使用**data 属性** ，data 类型是 **Object** 。

### [\#](component.html#自定义组件生命周期){.header-anchor} 自定义组件生命周期：

`onInit` ：表示组件ViewModel的数据已经准备好，可以开始使用页面中的数据。

`onReady` ：表示组件ViewModel的模板已经编译完成，可以开始获取 DOM 节点。

`onDestroy`
：组件被销毁时调用，组件销毁时应该做一些释放资源的操作，例如释放定时器等。

## [\#](component.html#组件引入){.header-anchor} 组件引入

vela中是通过`<import>`标签引入组件，如下面代码所示：

::: {.language-html .extra-class}
``` language-html
<import name="XXX" src="XXX"></import>
```
:::

`<import>`标签中的`src`属性指定自定义组件的地址，`name`属性指定在父组件中引用该组件时使用的
**标签名称**。

**示例如下：**

::: {.language-html .extra-class}
``` language-html
<import name="comp-part1" src="./part1"></import>

<template>
  <div class="tutorial-page">
    <text class="tutorial-title">引入组件：</text>
    <comp-part1></comp-part1>
  </div>
</template>

<style lang="less">
  .tutorial-page {
    flex-direction: column;
    padding: 20px 10px;
  }
  .tutorial-title {
      font-weight: bold;
  }
</style>

<script>
  // 父组件
  export default {
    private: {},
    onInit() {
      console.log('引入组件')
    }
  }
</script>
```
:::

## [\#](component.html#父子组件通信){.header-anchor} 父子组件通信

### [\#](component.html#父组件通过-prop-向子组件传递数据){.header-anchor} 父组件通过 Prop 向子组件传递数据

父组件向子组件传递数据，通过在子组件的`props`属性中声明对外暴露的属性名称，然后在组件引用标签上声明传递的父组件数据，详见[Props](Props.html)部分。

**示例如下：**

::: {.language-html .extra-class}
``` language-html
<!-- 子组件 -->
<template>
  <div class="child-demo">
    <text class="title">子组件:</text>
    <text>{{ say }}</text>
    <text>{{ propObject.name }}</text>
  </div>
</template>
<script>
  export default {
    props: ['say', 'propObject'],
    onInit() {
      console.info(`外部传递的数据：`, this.say, this.propObject)
    }
  }
</script>
```
:::

::: {.language-html .extra-class}
``` language-html
<!-- 父组件 -->
<import name="comp" src="./comp"></import>
<template>
  <div class="parent-demo">
    <comp say="{{say}}" prop-object="{{obj}}"></comp>
  </div>
</template>
<script>
  export default {
    private: {
      say:'hello'
      obj:{
        name:'child-demo'
      }
    }
  }
</script>
```
:::

### [\#](component.html#子组件对父组件通信){.header-anchor} 子组件对父组件通信

-   子组件通过`$emit()`触发在节点上绑定的自定义事件来执行父组件的方法，如父组件与组件一；
-   子组件通过`$dispatch()`触发自定义事件，父组件通过`$on()`监控自定义事件的触发，如父组件与组件二；

**示例如下：**

::: {.language-html .extra-class}
``` language-html
 <!-- 父组件 -->
<import name="comp1" src="./comp1.ux"></import>
<import name="comp2" src="./comp2.ux"></import>
<import name="comp3" src="./comp3.ux"></import>
<template>
  <div class="parent-demo">
    <text>我是父组件count:{{count}}</text>
    <comp1 count="{{count}}" onemit-evt="emitEvt"></comp1>

    <text>我是父组件num:{{num}}</text>
    <comp2 num="{{num}}"></comp2>

    <text>我是父组件age:{{age}}</text>
    <input type="button" onclick="evtTypeEmit" value="触发$broadcast()"></input>
    <comp3></comp3>
  </div>
</template>

<script>
  export default {
    private:{
      count:20,
      num:20,
      age:18
    },
    onInit(){
      this.$on('dispatchEvt',this.dispatchEvt)
    },
    emitEvt(evt){
      this.count = evt.detail.count
    },
    dispatchEvt(evt){
      this.num = evt.detail.num
    },
    evtTypeEmit(){
      this.$broadcast('broadevt',{
        age:19
      })
    },
  }
</script>
```
:::

::: {.language-html .extra-class}
``` language-html
<!-- comp1 -->
<template>
  <div class="child-demo">
    <text>我是子组件一count:{{compCount}}</text>
    <input type="button" onclick='addHandler' value='add'></input>
  </div>
</template>
<script>
  export default {
    props: ['count'],
    data(){
      return{
        compCount:this.count
      }
    },
    addHandler(){
      this.compCount ++
      this.$emit('emitEvt',{
        count:this.compCount
      })
    },
  }
</script>
```
:::

::: {.language-html .extra-class}
``` language-html
<!-- comp2 -->
<template>
  <div class="child-demo">
    <text>我是子组件二num:{{compNum}}</text>
    <input type="button" onclick='delHandler' value='del'></input>
  </div>
</template>
<script>
  export default {
    props: ['num'],
    data(){
      return{
        compNum:this.num
      }
    },
    delHandler(){
      this.compNum --
      this.$dispatch('dispatchEvt',{
        num:this.compNum
      })
    },
  }
</script>
```
:::

::: {.language-html .extra-class}
``` language-html
<!-- comp3 -->
<template>
  <div class="child-demo">
    <text>我是子组件三age:{{compAge}}</text>
  </div>
</template>
<script>
  export default {
    props:[],
    data(){
      return{
        compAge:null
      }
    },
    onInit(){
      this.$on('broadevt',this.broadevt)
    },
    broadevt(evt){
      this.compAge = evt.detail.age
    }
  }
</script>
```
:::

框架向开发者提供了双向的事件传递

-   向下传递：父组件触发，子组件响应；调用`parentVm.$broadcast()`完成向下传递，如：broadevt
-   向上传递：子组件触发，父组件响应；调用`childVm.$dispatch()`完成向上传递，如：dispatchEvt

**提示：**

-   触发时传递参数，再接收时使用`evt.detail`来获取参数
-   当传递结束后，可以调用`evt.stop()`来结束传递,否则会一直传递下去
:::

::: page-nav
[ ← [计算属性](computed.html){.prev} ]{.prev} [
[页面样式与布局](../style/page-style-and-layout.html) → ]{.next}
:::
:::

::: toc
::: on-this-page
快速导航
:::

::: {.vuepress-toc-item .vuepress-toc-h2 .active}
[组件自定义](component.html#组件自定义 "组件自定义")
:::

::: {.vuepress-toc-item .vuepress-toc-h3}
[自定义组件生命周期：](component.html#自定义组件生命周期 "自定义组件生命周期：")
:::

::: {.vuepress-toc-item .vuepress-toc-h2}
[组件引入](component.html#组件引入 "组件引入")
:::

::: {.vuepress-toc-item .vuepress-toc-h2}
[父子组件通信](component.html#父子组件通信 "父子组件通信")
:::

::: {.vuepress-toc-item .vuepress-toc-h3}
[父组件通过 Prop
向子组件传递数据](component.html#父组件通过-prop-向子组件传递数据 "父组件通过 Prop 向子组件传递数据")
:::

::: {.vuepress-toc-item .vuepress-toc-h3}
[子组件对父组件通信](component.html#子组件对父组件通信 "子组件对父组件通信")
:::
:::
:::

::: global-ui
:::
:::
